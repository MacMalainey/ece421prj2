[x] - Refactor for privatization

[x] - Write tests
    [x] - Red Black Tree
        [x] - Insert Cases
            [x] - (R, R)
            [x] - (R, B)
            [x] - (B, _)
        [x] - Delete Cases
            [x] - (R, _)
            [x] - (B, R)
            [x] - (B, B(R))
            [x] - (B, B(B))
    [x]] - AVL Tree
        [x] - Insert Case
            [x] - Balanced
            [x] - Unbalanced
        [x] - Delete Case
            [x] - Balanced
            [x] - Unbalanced

[x] - Write unbalanced tree

[] - CLI
    [] - Allow choosing of the type tree (and switching between them)
    [] - Allow deleting from the tree
    [] - Allow inserting into the tree
    [] - Allow clearing the tree
    [] - Allow pretty printing (use Debug trait with pretty print flag) of the tree
    [] - Allow inorder printing (use Display trait) of the tree
    [] - Allow checking if the tree is empty
    [] - Allow checking the height of the tree
    [] - Allow checking the number of leaves on the tree

[x] - Benchmarks
    [x] - Comment on results
        [x] - Which tree is better performance wise?
        [x] - Are other cases needed?
        [x] - Are additional structures required (such as baseline of unbalanced tree)?
    [] - Embed benchmark results in design doc
    [x] - Additional benchmarks for deletion cases
    [x] - Additional benchmarks for unbalanced cases
    [x] - Mention addition benchmarks (do not include in report)

[] - Design doc
    [x] - Major Innovations
        [x] - Ability to implement own balancing types with SAFE API for it
        [x] - Same base code used for unbalanced tree (which type is provided)
    [x] - Design Rationalle
        [x] - Design questions
            [x] - What does a Red-Black tree provide that cannot be accomplished with ordinary binary search trees?
            [x] - Do you need to apply any kind of error handling in your system (panic macro, Option<T>, Result<T, E>, etc)
            [x] - What components do the Red-Black tree and AVL tree have in common?
            [x] - How do we construct our design to "allow it to be efficiently and effectively extended"? (examples: 2-3-4 tree, B-tree)
        [x] - Rationalle
    [x] - Known errors, faults, defects, missing functionality
        [x] - Missing functionality for DIY balance API
            [x] - Only move once relative to node (Lacking Robustness)
    [] - User Manual
        [] - Using a Tree
        [] - Using pre-made balances
        [] - Using DIY balance API
        [] - Using CLI
    [] - 2 Minute video for marketting